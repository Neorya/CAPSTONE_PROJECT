"""
Student Results and Scoring API Module

Provides endpoints for:
- Getting all test results for a student's solution in a game session
- Getting scores for students in a game session

Related User Story: Display test results with pass/fail indicators and calculate student scores
"""

from typing import List, Optional
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
from pydantic import BaseModel, Field

# Import ORM models
from models import (
    Student,
    GameSession,
    Match,
    MatchesForGame,
    StudentJoinGame,
    Test,
    StudentTest,
    StudentSolution,
    StudentSolutionTest
)

from database import get_db

# ============================================================================
# Pydantic Response Models
# ============================================================================

class TestResultResponse(BaseModel):
    """
    Response model for individual test case result.
    """
    test_id: int = Field(..., description="ID of the test")
    test_type: str = Field(..., description="Type of test: 'teacher' or 'student'")
    provider: str = Field(..., description="Test provider: 'teacher' or 'student'")
    scope: Optional[str] = Field(None, description="Test scope: 'public' or 'private' (only for teacher tests)")
    test_input: Optional[str] = Field(None, description="Input for the test")
    expected_output: Optional[str] = Field(None, description="Expected output")
    actual_output: str = Field(..., description="Actual output generated by the student's code")
    status: str = Field(..., description="Test status: 'Passed' or 'Failed'")


class SolutionTestResultsResponse(BaseModel):
    """
    Response model for all test results of a student's solution.
    """
    solution_id: int = Field(..., description="ID of the student's solution")
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    match_id: int = Field(..., description="ID of the match")
    match_title: str = Field(..., description="Title of the match")
    game_id: int = Field(..., description="ID of the game session")
    code: str = Field(..., description="Student's submitted code")
    total_tests: int = Field(..., description="Total number of tests")
    passed_tests: int = Field(..., description="Number of tests passed")
    failed_tests: int = Field(..., description="Number of tests failed")
    score_display: str = Field(..., description="Score display (e.g., '8/10 tests passed')")
    implementation_score_percentage: float = Field(..., description="Implementation score as percentage (0-100)")
    test_results: List[TestResultResponse] = Field(..., description="List of all test results")


class StudentScoreBreakdown(BaseModel):
    """
    Detailed score breakdown for a student in a specific match.
    """
    match_id: int = Field(..., description="ID of the match")
    match_title: str = Field(..., description="Title of the match")
    implementation_score: float = Field(..., description="Score from implementation (0-50)")
    review_score: float = Field(..., description="Score from reviews (0-50, placeholder for future)")
    total_score: float = Field(..., description="Total score for this match (0-100)")
    tests_passed: int = Field(..., description="Number of tests passed")
    total_tests: int = Field(..., description="Total number of tests")


class StudentGameScoreResponse(BaseModel):
    """
    Response model for a student's score in a game session.
    """
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    email: str = Field(..., description="Student's email")
    game_id: int = Field(..., description="ID of the game session")
    game_name: str = Field(..., description="Name of the game session")
    overall_score: float = Field(..., description="Overall score across all matches")
    matches: List[StudentScoreBreakdown] = Field(..., description="Score breakdown per match")


class GameSessionScoresResponse(BaseModel):
    """
    Response model for all students' scores in a game session.
    """
    game_id: int = Field(..., description="ID of the game session")
    game_name: str = Field(..., description="Name of the game session")
    total_students: int = Field(..., description="Number of students in the game session")
    students_scores: List[StudentGameScoreResponse] = Field(..., description="List of all students' scores")


# ============================================================================
# Helper Functions
# ============================================================================

def _calculate_implementation_score(passed_tests: int, total_tests: int) -> float:
    """
    Calculate implementation score based on passed tests.
    
    Implementation accounts for 50% of total score.
    Each failed test costs 1/N of the implementation score (50 points).
    
    Args:
        passed_tests: Number of tests passed
        total_tests: Total number of tests
    
    Returns:
        Implementation score out of 50
    """
    if total_tests == 0:
        return 0.0
    
    # Each test is worth (50 / total_tests) points
    score_per_test = 50.0 / total_tests
    implementation_score = passed_tests * score_per_test
    
    return round(implementation_score, 2)


def _get_test_status(actual_output: str, expected_output: Optional[str]) -> str:
    """
    Determine test status.
    
    Args:
        actual_output: Output generated by student's code
        expected_output: Expected output from the test
    
    Returns:
        Status string: 'Passed', 'Failed', or 'Unknown'
    """
    if expected_output is None:
        # If no expected output is defined, we cannot determine pass/fail
        return "Unknown"
    
    # Simple string comparison (you may want to add more sophisticated comparison)
    if actual_output.strip() == expected_output.strip():
        return "Passed"
    else:
        return "Failed"


# ============================================================================
# API Router
# ============================================================================

router = APIRouter(
    prefix="/api/student-results",
    tags=["Student Results and Scoring"]
)


# ============================================================================
# Endpoint 1: Get Test Results for Student Solution
# ============================================================================

@router.get(
    "/tests/{solution_id}",
    response_model=SolutionTestResultsResponse,
    status_code=status.HTTP_200_OK,
    summary="Get all test results for a student's solution",
    description="""
    Retrieves all test results (teacher and student tests) for a specific student solution.
    
    For each test case, displays:
    - Input and expected output
    - Actual output generated by the student's code
    - Status (Passed/Failed) with visual indicators (✓/✗)
    - Test type (teacher/student) and scope (public/private for teacher tests)
    
    Also calculates and displays the implementation score based on passed tests.
    """
)
def get_solution_test_results(
    solution_id: int,
    db: Session = Depends(get_db)
) -> SolutionTestResultsResponse:
    """
    Get all test results for a specific student solution.
    
    Args:
        solution_id: ID of the student solution
        db: Database session
    
    Returns:
        SolutionTestResultsResponse with all test results and score information
    
    Raises:
        HTTPException: If solution not found
    """
    
    # Get the student solution
    solution = db.query(StudentSolution).filter(
        StudentSolution.solution_id == solution_id
    ).first()
    
    if not solution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student solution with ID {solution_id} not found"
        )
    
    # Get student information
    student = db.query(Student).filter(
        Student.student_id == solution.student_id
    ).first()
    
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {solution.student_id} not found"
        )
    
    # Get match and game information
    match_for_game = db.query(MatchesForGame).filter(
        MatchesForGame.match_for_game_id == solution.match_for_game_id
    ).first()
    
    if not match_for_game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match for game with ID {solution.match_for_game_id} not found"
        )
    
    match = db.query(Match).filter(
        Match.match_id == match_for_game.match_id
    ).first()
    
    if not match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match with ID {match_for_game.match_id} not found"
        )
    
    # Get all test results for this solution
    test_results_data = []
    passed_count = 0
    total_count = 0
    
    # Query all test results from student_solution_tests
    test_results = db.query(StudentSolutionTest).filter(
        StudentSolutionTest.solution_id == solution_id
    ).all()
    
    # Extract all teacher_test_ids and student_test_ids to fetch in batch (fix N+1 query)
    teacher_test_ids = [tr.teacher_test_id for tr in test_results]
    student_test_ids = [tr.student_test_id for tr in test_results]
    
    # Fetch all teacher tests and student tests in single queries
    teacher_tests = db.query(Test).filter(Test.test_id.in_(teacher_test_ids)).all()
    student_tests = db.query(StudentTest).filter(StudentTest.test_id.in_(student_test_ids)).all()
    
    # Create lookup dictionaries for O(1) access
    teacher_test_map = {t.test_id: t for t in teacher_tests}
    student_test_map = {t.test_id: t for t in student_tests}
    
    for test_result in test_results:
        # Each row contains both a teacher_test_id and student_test_id
        # The test_output is the actual output from running the code
        # We compare against the teacher test's expected output
        
        teacher_test = teacher_test_map.get(test_result.teacher_test_id)
        student_test = student_test_map.get(test_result.student_test_id)
        
        if not teacher_test or not student_test:
            continue
        
        total_count += 1
        
        # Determine if test passed by comparing actual output to teacher's expected output
        status_str = _get_test_status(
            test_result.test_output,
            teacher_test.test_out
        )
        
        if status_str == "Passed":
            passed_count += 1
        
        # Determine the provider: if student_test was created by another student, it's a student test
        # Otherwise, it's a teacher test
        # Check if the student_test belongs to the current student or another student
        is_student_provided = student_test.student_id != solution.student_id
        
        if is_student_provided:
            # This is a student-provided test (from peer review)
            test_results_data.append(TestResultResponse(
                test_id=student_test.test_id,
                test_type="student",
                provider="student",
                scope=None,  # Student tests don't have public/private scope
                test_input=student_test.test_in,
                expected_output=student_test.test_out,
                actual_output=test_result.test_output,
                status=status_str
            ))
        else:
            # This is a teacher test
            test_results_data.append(TestResultResponse(
                test_id=teacher_test.test_id,
                test_type="teacher",
                provider="teacher",
                scope=teacher_test.scope.value,
                test_input=teacher_test.test_in,
                expected_output=teacher_test.test_out,
                actual_output=test_result.test_output,
                status=status_str
            ))
    
    
    # Calculate scores
    failed_count = total_count - passed_count
    implementation_score_pct = (passed_count / total_count * 100) if total_count > 0 else 0
    
    return SolutionTestResultsResponse(
        solution_id=solution.solution_id,
        student_id=student.student_id,
        student_name=f"{student.first_name} {student.last_name}",
        match_id=match.match_id,
        match_title=match.title,
        game_id=match_for_game.game_id,
        code=solution.code,
        total_tests=total_count,
        passed_tests=passed_count,
        failed_tests=failed_count,
        score_display=f"{passed_count}/{total_count} tests passed",
        implementation_score_percentage=round(implementation_score_pct, 2),
        test_results=test_results_data
    )


# ============================================================================
# Endpoint 2: Get Student Score for Game Session
# ============================================================================

@router.get(
    "/score/student/{student_id}/game/{game_id}",
    response_model=StudentGameScoreResponse,
    status_code=status.HTTP_200_OK,
    summary="Get a student's score for a game session",
    description="""
    Retrieves the complete score breakdown for a specific student in a game session.
    
    Includes:
    - Overall score across all matches in the game session
    - Individual match scores with implementation and review breakdowns
    - Number of tests passed for each match
    
    Note: Review scores are placeholders (0) for future implementation.
    """
)
def get_student_game_score(
    student_id: int,
    game_id: int,
    db: Session = Depends(get_db)
) -> StudentGameScoreResponse:
    """
    Get score breakdown for a specific student in a game session.
    
    Args:
        student_id: ID of the student
        game_id: ID of the game session
        db: Database session
    
    Returns:
        StudentGameScoreResponse with complete score breakdown
    
    Raises:
        HTTPException: If student or game session not found, or student not in game
    """
    
    # Verify student exists
    student = db.query(Student).filter(Student.student_id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {student_id} not found"
        )
    
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # Verify student is in the game session
    student_join = db.query(StudentJoinGame).filter(
        and_(
            StudentJoinGame.student_id == student_id,
            StudentJoinGame.game_id == game_id
        )
    ).first()
    
    if not student_join:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student {student_id} is not enrolled in game session {game_id}"
        )
    
    # Get all matches for this game
    matches_for_game = db.query(MatchesForGame).filter(
        MatchesForGame.game_id == game_id
    ).all()
    
    match_scores = []
    overall_score = 0.0
    
    for match_for_game in matches_for_game:
        # Get match details
        match = db.query(Match).filter(
            Match.match_id == match_for_game.match_id
        ).first()
        
        if not match:
            continue
        
        # Get student's solution for this match
        solution = db.query(StudentSolution).filter(
            and_(
                StudentSolution.student_id == student_id,
                StudentSolution.match_for_game_id == match_for_game.match_for_game_id
            )
        ).first()
        
        if not solution:
            # Student hasn't submitted a solution for this match
            match_scores.append(StudentScoreBreakdown(
                match_id=match.match_id,
                match_title=match.title,
                implementation_score=0.0,
                review_score=0.0,  # Placeholder for future
                total_score=0.0,
                tests_passed=0,
                total_tests=0
            ))
            continue
        
        # Get test results for this solution
        test_results = db.query(StudentSolutionTest).filter(
            StudentSolutionTest.solution_id == solution.solution_id
        ).all()
        
        total_tests = len(test_results)
        passed_tests = 0
        
        # Fetch all teacher tests for these results in one query (fix N+1 query)
        if test_results:
            teacher_test_ids = [tr.teacher_test_id for tr in test_results]
            teacher_tests = db.query(Test).filter(Test.test_id.in_(teacher_test_ids)).all()
            teacher_test_map = {t.test_id: t for t in teacher_tests}
            
            # Count passed tests
            for test_result in test_results:
                teacher_test = teacher_test_map.get(test_result.teacher_test_id)
                
                if teacher_test:
                    status_str = _get_test_status(
                        test_result.test_output,
                        teacher_test.test_out
                    )
                    if status_str == "Passed":
                        passed_tests += 1
        
        # Calculate implementation score (50% of total, max 50 points)
        implementation_score = _calculate_implementation_score(passed_tests, total_tests)
        
        # Review score placeholder (will be implemented in future)
        review_score = 0.0
        
        # Total score for this match
        match_total_score = implementation_score + review_score
        
        match_scores.append(StudentScoreBreakdown(
            match_id=match.match_id,
            match_title=match.title,
            implementation_score=implementation_score,
            review_score=review_score,
            total_score=match_total_score,
            tests_passed=passed_tests,
            total_tests=total_tests
        ))
        
        overall_score += match_total_score
    
    return StudentGameScoreResponse(
        student_id=student.student_id,
        student_name=f"{student.first_name} {student.last_name}",
        email=student.email,
        game_id=game.game_id,
        game_name=game.name,
        overall_score=round(overall_score, 2),
        matches=match_scores
    )


# ============================================================================
# Endpoint 3: Get All Students' Scores for a Game Session
# ============================================================================

@router.get(
    "/score/game/{game_id}",
    response_model=GameSessionScoresResponse,
    status_code=status.HTTP_200_OK,
    summary="Get all students' scores for a game session",
    description="""
    Retrieves scores for all students participating in a game session.
    
    Provides a complete overview of:
    - All students enrolled in the game session
    - Each student's overall score and per-match breakdown
    - Implementation and review scores (review scores are placeholders for future)
    
    Useful for teachers to see the leaderboard and overall performance.
    
    OPTIMIZED: Uses bulk queries instead of N+1 pattern for better performance.
    """
)
def get_game_session_scores(
    game_id: int,
    db: Session = Depends(get_db)
) -> GameSessionScoresResponse:
    """
    Get scores for all students in a game session.
    
    PERFORMANCE OPTIMIZATION:
    - Uses bulk queries to fetch all data in 5-6 database round-trips
    - Avoids N+1 query pattern (previously ~8 queries per student)
    - Aggregates scores in-memory for efficiency
    
    Args:
        game_id: ID of the game session
        db: Database session
    
    Returns:
        GameSessionScoresResponse with all students' scores
    
    Raises:
        HTTPException: If game session not found
    """
    
    # 1. Verify game session exists (1 query)
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # 2. Get all student joins for this game session (1 query)
    student_joins = db.query(StudentJoinGame).filter(
        StudentJoinGame.game_id == game_id
    ).all()
    
    if not student_joins:
        return GameSessionScoresResponse(
            game_id=game.game_id,
            game_name=game.name,
            total_students=0,
            students_scores=[]
        )
    
    student_ids = [sj.student_id for sj in student_joins]
    
    # 3. Fetch all students in bulk (1 query)
    students = db.query(Student).filter(Student.student_id.in_(student_ids)).all()
    student_map = {s.student_id: s for s in students}
    
    # 4. Get all matches for this game session (1 query)
    matches_for_game = db.query(MatchesForGame).filter(
        MatchesForGame.game_id == game_id
    ).all()
    
    if not matches_for_game:
        # No matches configured - return students with zero scores
        students_scores = []
        for student_id in student_ids:
            student = student_map.get(student_id)
            if student:
                students_scores.append(StudentGameScoreResponse(
                    student_id=student.student_id,
                    student_name=f"{student.first_name} {student.last_name}",
                    email=student.email,
                    game_id=game.game_id,
                    game_name=game.name,
                    overall_score=0.0,
                    matches=[]
                ))
        return GameSessionScoresResponse(
            game_id=game.game_id,
            game_name=game.name,
            total_students=len(students_scores),
            students_scores=students_scores
        )
    
    match_for_game_ids = [mfg.match_for_game_id for mfg in matches_for_game]
    match_ids = [mfg.match_id for mfg in matches_for_game]
    
    # 5. Fetch all match details in bulk (1 query)
    matches = db.query(Match).filter(Match.match_id.in_(match_ids)).all()
    match_map = {m.match_id: m for m in matches}
    
    # Create mapping from match_for_game_id to match details
    mfg_to_match = {}
    for mfg in matches_for_game:
        mfg_to_match[mfg.match_for_game_id] = match_map.get(mfg.match_id)
    
    # 6. Fetch all solutions for all students in this game (1 query)
    all_solutions = db.query(StudentSolution).filter(
        StudentSolution.student_id.in_(student_ids),
        StudentSolution.match_for_game_id.in_(match_for_game_ids)
    ).all()
    
    # Create nested map: student_id -> match_for_game_id -> solution
    solution_map = {}
    for sol in all_solutions:
        if sol.student_id not in solution_map:
            solution_map[sol.student_id] = {}
        solution_map[sol.student_id][sol.match_for_game_id] = sol
    
    # 7. Fetch all test results for all solutions in bulk (1 query)
    solution_ids = [sol.solution_id for sol in all_solutions]
    all_test_results = []
    if solution_ids:
        all_test_results = db.query(StudentSolutionTest).filter(
            StudentSolutionTest.solution_id.in_(solution_ids)
        ).all()
    
    # Create map: solution_id -> list of test results
    test_results_map = {}
    for tr in all_test_results:
        if tr.solution_id not in test_results_map:
            test_results_map[tr.solution_id] = []
        test_results_map[tr.solution_id].append(tr)
    
    # 8. Fetch all teacher tests for test result comparison (1 query)
    teacher_test_ids = list(set(tr.teacher_test_id for tr in all_test_results))
    teacher_tests = []
    if teacher_test_ids:
        teacher_tests = db.query(Test).filter(Test.test_id.in_(teacher_test_ids)).all()
    teacher_test_map = {t.test_id: t for t in teacher_tests}
    
    # Now aggregate scores in memory
    students_scores = []
    
    for student_id in student_ids:
        student = student_map.get(student_id)
        if not student:
            continue
        
        match_scores = []
        overall_score = 0.0
        
        for mfg in matches_for_game:
            match = mfg_to_match.get(mfg.match_for_game_id)
            if not match:
                continue
            
            # Get solution for this student and match
            student_solutions = solution_map.get(student_id, {})
            solution = student_solutions.get(mfg.match_for_game_id)
            
            if not solution:
                # Student hasn't submitted a solution for this match
                match_scores.append(StudentScoreBreakdown(
                    match_id=match.match_id,
                    match_title=match.title,
                    implementation_score=0.0,
                    review_score=0.0,
                    total_score=0.0,
                    tests_passed=0,
                    total_tests=0
                ))
                continue
            
            # Get test results for this solution
            test_results = test_results_map.get(solution.solution_id, [])
            total_tests = len(test_results)
            passed_tests = 0
            
            for tr in test_results:
                teacher_test = teacher_test_map.get(tr.teacher_test_id)
                if teacher_test:
                    status_str = _get_test_status(tr.test_output, teacher_test.test_out)
                    if status_str == "Passed":
                        passed_tests += 1
            
            # Calculate implementation score
            implementation_score = _calculate_implementation_score(passed_tests, total_tests)
            review_score = 0.0  # Placeholder for future
            match_total_score = implementation_score + review_score
            
            match_scores.append(StudentScoreBreakdown(
                match_id=match.match_id,
                match_title=match.title,
                implementation_score=implementation_score,
                review_score=review_score,
                total_score=match_total_score,
                tests_passed=passed_tests,
                total_tests=total_tests
            ))
            
            overall_score += match_total_score
        
        students_scores.append(StudentGameScoreResponse(
            student_id=student.student_id,
            student_name=f"{student.first_name} {student.last_name}",
            email=student.email,
            game_id=game.game_id,
            game_name=game.name,
            overall_score=round(overall_score, 2),
            matches=match_scores
        ))
    
    # Sort students by overall score (descending)
    students_scores.sort(key=lambda x: x.overall_score, reverse=True)
    
    return GameSessionScoresResponse(
        game_id=game.game_id,
        game_name=game.name,
        total_students=len(students_scores),
        students_scores=students_scores
    )
