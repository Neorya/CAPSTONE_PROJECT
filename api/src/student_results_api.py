"""
Student Results and Scoring API Module

Provides endpoints for:
- Getting all test results for a student's solution in a game session
- Getting scores for students in a game session

Related User Story: Display test results with pass/fail indicators and calculate student scores
"""

from typing import List, Optional
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
from pydantic import BaseModel, Field

# Import ORM models
from models import (
    Student,
    GameSession,
    Match,
    MatchesForGame,
    StudentJoinGame,
    Test,
    StudentTest,
    StudentSolution,
    StudentSolutionTest
)

from database import get_db

# ============================================================================
# Pydantic Response Models
# ============================================================================

class TestResultResponse(BaseModel):
    """
    Response model for individual test case result.
    """
    test_id: int = Field(..., description="ID of the test")
    test_type: str = Field(..., description="Type of test: 'teacher' or 'student'")
    scope: Optional[str] = Field(None, description="Test scope: 'public' or 'private' (only for teacher tests)")
    test_input: Optional[str] = Field(None, description="Input for the test")
    expected_output: Optional[str] = Field(None, description="Expected output")
    actual_output: str = Field(..., description="Actual output generated by the student's code")
    status: str = Field(..., description="Test status: 'Passed' or 'Failed'")
    visual_indicator: str = Field(..., description="Visual indicator: '✓' for passed, '✗' for failed")


class SolutionTestResultsResponse(BaseModel):
    """
    Response model for all test results of a student's solution.
    """
    solution_id: int = Field(..., description="ID of the student's solution")
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    match_id: int = Field(..., description="ID of the match")
    match_title: str = Field(..., description="Title of the match")
    game_id: int = Field(..., description="ID of the game session")
    code: str = Field(..., description="Student's submitted code")
    total_tests: int = Field(..., description="Total number of tests")
    passed_tests: int = Field(..., description="Number of tests passed")
    failed_tests: int = Field(..., description="Number of tests failed")
    score_display: str = Field(..., description="Score display (e.g., '8/10 tests passed')")
    implementation_score_percentage: float = Field(..., description="Implementation score as percentage (0-100)")
    test_results: List[TestResultResponse] = Field(..., description="List of all test results")


class StudentScoreBreakdown(BaseModel):
    """
    Detailed score breakdown for a student in a specific match.
    """
    match_id: int = Field(..., description="ID of the match")
    match_title: str = Field(..., description="Title of the match")
    implementation_score: float = Field(..., description="Score from implementation (0-50)")
    review_score: float = Field(..., description="Score from reviews (0-50, placeholder for future)")
    total_score: float = Field(..., description="Total score for this match (0-100)")
    tests_passed: int = Field(..., description="Number of tests passed")
    total_tests: int = Field(..., description="Total number of tests")


class StudentGameScoreResponse(BaseModel):
    """
    Response model for a student's score in a game session.
    """
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    email: str = Field(..., description="Student's email")
    game_id: int = Field(..., description="ID of the game session")
    game_name: str = Field(..., description="Name of the game session")
    overall_score: float = Field(..., description="Overall score across all matches")
    matches: List[StudentScoreBreakdown] = Field(..., description="Score breakdown per match")


class GameSessionScoresResponse(BaseModel):
    """
    Response model for all students' scores in a game session.
    """
    game_id: int = Field(..., description="ID of the game session")
    game_name: str = Field(..., description="Name of the game session")
    total_students: int = Field(..., description="Number of students in the game session")
    students_scores: List[StudentGameScoreResponse] = Field(..., description="List of all students' scores")


# ============================================================================
# Helper Functions
# ============================================================================

def _calculate_implementation_score(passed_tests: int, total_tests: int) -> float:
    """
    Calculate implementation score based on passed tests.
    
    Implementation accounts for 50% of total score.
    Each failed test costs 1/N of the implementation score (50 points).
    
    Args:
        passed_tests: Number of tests passed
        total_tests: Total number of tests
    
    Returns:
        Implementation score out of 50
    """
    if total_tests == 0:
        return 0.0
    
    # Each test is worth (50 / total_tests) points
    score_per_test = 50.0 / total_tests
    implementation_score = passed_tests * score_per_test
    
    return round(implementation_score, 2)


def _get_test_status_and_indicator(actual_output: str, expected_output: Optional[str]) -> tuple:
    """
    Determine test status and visual indicator.
    
    Args:
        actual_output: Output generated by student's code
        expected_output: Expected output from the test
    
    Returns:
        Tuple of (status_string, visual_indicator)
    """
    if expected_output is None:
        # If no expected output is defined, we cannot determine pass/fail
        return ("Unknown", "?")
    
    # Simple string comparison (you may want to add more sophisticated comparison)
    if actual_output.strip() == expected_output.strip():
        return ("Passed", "✓")
    else:
        return ("Failed", "✗")


# ============================================================================
# API Router
# ============================================================================

router = APIRouter(
    prefix="/api/student-results",
    tags=["Student Results and Scoring"]
)


# ============================================================================
# Endpoint 1: Get Test Results for Student Solution
# ============================================================================

@router.get(
    "/tests/{solution_id}",
    response_model=SolutionTestResultsResponse,
    status_code=status.HTTP_200_OK,
    summary="Get all test results for a student's solution",
    description="""
    Retrieves all test results (teacher and student tests) for a specific student solution.
    
    For each test case, displays:
    - Input and expected output
    - Actual output generated by the student's code
    - Status (Passed/Failed) with visual indicators (✓/✗)
    - Test type (teacher/student) and scope (public/private for teacher tests)
    
    Also calculates and displays the implementation score based on passed tests.
    """
)
def get_solution_test_results(
    solution_id: int,
    db: Session = Depends(get_db)
) -> SolutionTestResultsResponse:
    """
    Get all test results for a specific student solution.
    
    Args:
        solution_id: ID of the student solution
        db: Database session
    
    Returns:
        SolutionTestResultsResponse with all test results and score information
    
    Raises:
        HTTPException: If solution not found
    """
    
    # Get the student solution
    solution = db.query(StudentSolution).filter(
        StudentSolution.solution_id == solution_id
    ).first()
    
    if not solution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student solution with ID {solution_id} not found"
        )
    
    # Get student information
    student = db.query(Student).filter(
        Student.student_id == solution.student_id
    ).first()
    
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {solution.student_id} not found"
        )
    
    # Get match and game information
    match_for_game = db.query(MatchesForGame).filter(
        MatchesForGame.match_for_game_id == solution.match_for_game_id
    ).first()
    
    if not match_for_game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match for game with ID {solution.match_for_game_id} not found"
        )
    
    match = db.query(Match).filter(
        Match.match_id == match_for_game.match_id
    ).first()
    
    if not match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match with ID {match_for_game.match_id} not found"
        )
    
    # Get all test results for this solution
    test_results_data = []
    passed_count = 0
    total_count = 0
    
    # Query all test results from student_solution_tests
    test_results = db.query(StudentSolutionTest).filter(
        StudentSolutionTest.solution_id == solution_id
    ).all()
    
    # Extract all teacher_test_ids and student_test_ids to fetch in batch (fix N+1 query)
    teacher_test_ids = [tr.teacher_test_id for tr in test_results]
    student_test_ids = [tr.student_test_id for tr in test_results]
    
    # Fetch all teacher tests and student tests in single queries
    teacher_tests = db.query(Test).filter(Test.test_id.in_(teacher_test_ids)).all()
    student_tests = db.query(StudentTest).filter(StudentTest.test_id.in_(student_test_ids)).all()
    
    # Create lookup dictionaries for O(1) access
    teacher_test_map = {t.test_id: t for t in teacher_tests}
    student_test_map = {t.test_id: t for t in student_tests}
    
    for test_result in test_results:
        # Each row contains both a teacher_test_id and student_test_id
        # The test_output is the actual output from running the code
        # We compare against the teacher test's expected output
        
        teacher_test = teacher_test_map.get(test_result.teacher_test_id)
        student_test = student_test_map.get(test_result.student_test_id)
        
        if not teacher_test or not student_test:
            continue
        
        total_count += 1
        
        # Determine if test passed by comparing actual output to teacher's expected output
        status_str, indicator = _get_test_status_and_indicator(
            test_result.test_output,
            teacher_test.test_out
        )
        
        if status_str == "Passed":
            passed_count += 1
        
        # Create a combined test result that shows both teacher and student test info
        # For the API response, we'll create one entry showing this is based on teacher test expectations
        test_results_data.append(TestResultResponse(
            test_id=teacher_test.test_id,
            test_type="teacher",
            scope=teacher_test.scope.value,
            test_input=teacher_test.test_in,
            expected_output=teacher_test.test_out,
            actual_output=test_result.test_output,
            status=status_str,
            visual_indicator=indicator
        ))
    
    # Calculate scores
    failed_count = total_count - passed_count
    implementation_score_pct = (passed_count / total_count * 100) if total_count > 0 else 0
    
    return SolutionTestResultsResponse(
        solution_id=solution.solution_id,
        student_id=student.student_id,
        student_name=f"{student.first_name} {student.last_name}",
        match_id=match.match_id,
        match_title=match.title,
        game_id=match_for_game.game_id,
        code=solution.code,
        total_tests=total_count,
        passed_tests=passed_count,
        failed_tests=failed_count,
        score_display=f"{passed_count}/{total_count} tests passed",
        implementation_score_percentage=round(implementation_score_pct, 2),
        test_results=test_results_data
    )


# ============================================================================
# Endpoint 2: Get Student Score for Game Session
# ============================================================================

@router.get(
    "/score/student/{student_id}/game/{game_id}",
    response_model=StudentGameScoreResponse,
    status_code=status.HTTP_200_OK,
    summary="Get a student's score for a game session",
    description="""
    Retrieves the complete score breakdown for a specific student in a game session.
    
    Includes:
    - Overall score across all matches in the game session
    - Individual match scores with implementation and review breakdowns
    - Number of tests passed for each match
    
    Note: Review scores are placeholders (0) for future implementation.
    """
)
def get_student_game_score(
    student_id: int,
    game_id: int,
    db: Session = Depends(get_db)
) -> StudentGameScoreResponse:
    """
    Get score breakdown for a specific student in a game session.
    
    Args:
        student_id: ID of the student
        game_id: ID of the game session
        db: Database session
    
    Returns:
        StudentGameScoreResponse with complete score breakdown
    
    Raises:
        HTTPException: If student or game session not found, or student not in game
    """
    
    # Verify student exists
    student = db.query(Student).filter(Student.student_id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {student_id} not found"
        )
    
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # Verify student is in the game session
    student_join = db.query(StudentJoinGame).filter(
        and_(
            StudentJoinGame.student_id == student_id,
            StudentJoinGame.game_id == game_id
        )
    ).first()
    
    if not student_join:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student {student_id} is not enrolled in game session {game_id}"
        )
    
    # Get all matches for this game
    matches_for_game = db.query(MatchesForGame).filter(
        MatchesForGame.game_id == game_id
    ).all()
    
    match_scores = []
    overall_score = 0.0
    
    for match_for_game in matches_for_game:
        # Get match details
        match = db.query(Match).filter(
            Match.match_id == match_for_game.match_id
        ).first()
        
        if not match:
            continue
        
        # Get student's solution for this match
        solution = db.query(StudentSolution).filter(
            and_(
                StudentSolution.student_id == student_id,
                StudentSolution.match_for_game_id == match_for_game.match_for_game_id
            )
        ).first()
        
        if not solution:
            # Student hasn't submitted a solution for this match
            match_scores.append(StudentScoreBreakdown(
                match_id=match.match_id,
                match_title=match.title,
                implementation_score=0.0,
                review_score=0.0,  # Placeholder for future
                total_score=0.0,
                tests_passed=0,
                total_tests=0
            ))
            continue
        
        # Get test results for this solution
        test_results = db.query(StudentSolutionTest).filter(
            StudentSolutionTest.solution_id == solution.solution_id
        ).all()
        
        total_tests = len(test_results)
        passed_tests = 0
        
        # Fetch all teacher tests for these results in one query (fix N+1 query)
        if test_results:
            teacher_test_ids = [tr.teacher_test_id for tr in test_results]
            teacher_tests = db.query(Test).filter(Test.test_id.in_(teacher_test_ids)).all()
            teacher_test_map = {t.test_id: t for t in teacher_tests}
            
            # Count passed tests
            for test_result in test_results:
                teacher_test = teacher_test_map.get(test_result.teacher_test_id)
                
                if teacher_test:
                    status_str, _ = _get_test_status_and_indicator(
                        test_result.test_output,
                        teacher_test.test_out
                    )
                    if status_str == "Passed":
                        passed_tests += 1
        
        # Calculate implementation score (50% of total, max 50 points)
        implementation_score = _calculate_implementation_score(passed_tests, total_tests)
        
        # Review score placeholder (will be implemented in future)
        review_score = 0.0
        
        # Total score for this match
        match_total_score = implementation_score + review_score
        
        match_scores.append(StudentScoreBreakdown(
            match_id=match.match_id,
            match_title=match.title,
            implementation_score=implementation_score,
            review_score=review_score,
            total_score=match_total_score,
            tests_passed=passed_tests,
            total_tests=total_tests
        ))
        
        overall_score += match_total_score
    
    return StudentGameScoreResponse(
        student_id=student.student_id,
        student_name=f"{student.first_name} {student.last_name}",
        email=student.email,
        game_id=game.game_id,
        game_name=game.name,
        overall_score=round(overall_score, 2),
        matches=match_scores
    )


# ============================================================================
# Endpoint 3: Get All Students' Scores for a Game Session
# ============================================================================

@router.get(
    "/score/game/{game_id}",
    response_model=GameSessionScoresResponse,
    status_code=status.HTTP_200_OK,
    summary="Get all students' scores for a game session",
    description="""
    Retrieves scores for all students participating in a game session.
    
    Provides a complete overview of:
    - All students enrolled in the game session
    - Each student's overall score and per-match breakdown
    - Implementation and review scores (review scores are placeholders for future)
    
    Useful for teachers to see the leaderboard and overall performance.
    """
)
def get_game_session_scores(
    game_id: int,
    db: Session = Depends(get_db)
) -> GameSessionScoresResponse:
    """
    Get scores for all students in a game session.
    
    Args:
        game_id: ID of the game session
        db: Database session
    
    Returns:
        GameSessionScoresResponse with all students' scores
    
    Raises:
        HTTPException: If game session not found
    """
    
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # Get all students in this game session
    student_joins = db.query(StudentJoinGame).filter(
        StudentJoinGame.game_id == game_id
    ).all()
    
    students_scores = []
    
    for student_join in student_joins:
        # Use the existing endpoint logic to get each student's score
        try:
            student_score = get_student_game_score(
                student_id=student_join.student_id,
                game_id=game_id,
                db=db
            )
            students_scores.append(student_score)
        except HTTPException:
            # Skip students that cause errors
            continue
    
    # Sort students by overall score (descending)
    students_scores.sort(key=lambda x: x.overall_score, reverse=True)
    
    return GameSessionScoresResponse(
        game_id=game.game_id,
        game_name=game.name,
        total_students=len(students_scores),
        students_scores=students_scores
    )
