"""
Student Results and Scoring API Module

Provides endpoints for:
- Getting all test results for a student's solution in a game session
- Getting scores for students in a game session

Related User Story: Display test results with pass/fail indicators and calculate student scores
"""

from typing import List, Optional, Dict, Annotated, Tuple
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
from pydantic import BaseModel, Field
from collections import defaultdict

from authentication.routes.auth_routes import get_current_user

# Import ORM models
from models import (
    Student,
    GameSession,
    Match,
    MatchesForGame,
    MatchSetting,
    StudentJoinGame,
    Test,
    StudentTest,
    StudentSolution,
    StudentSolutionTest,
    StudentAssignedReview,
    StudentReviewVote,
    VoteType
)

from database import get_db

# ============================================================================
# Pydantic Response Models
# ============================================================================

class TestResultResponse(BaseModel):
    """
    Response model for individual test case result.
    """
    test_id: int = Field(..., description="ID of the test")
    test_type: str = Field(..., description="Type of test: 'teacher' or 'student'")
    provider: str = Field(..., description="Test provider: 'teacher' or 'student'")
    scope: Optional[str] = Field(None, description="Test scope: 'public' or 'private' (only for teacher tests)")
    test_input: Optional[str] = Field(None, description="Input for the test")
    expected_output: Optional[str] = Field(None, description="Expected output")
    actual_output: str = Field(..., description="Actual output generated by the student's code")
    status: str = Field(..., description="Test status: 'Passed' or 'Failed'")
    comment: Optional[str] = Field(None, description="Reviewer comment (for proof tests from peer reviews)")


class SolutionTestResultsResponse(BaseModel):
    """
    Response model for all test results of a student's solution.
    """
    solution_id: int = Field(..., description="ID of the student's solution")
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    match_id: int = Field(..., description="ID of the match")
    match_title: str = Field(..., description="Title of the match")
    game_id: int = Field(..., description="ID of the game session")
    code: str = Field(..., description="Student's submitted code")
    total_tests: int = Field(..., description="Total number of tests")
    passed_tests: int = Field(..., description="Number of tests passed")
    failed_tests: int = Field(..., description="Number of tests failed")
    score_display: str = Field(..., description="Score display (e.g., '8/10 tests passed')")
    session_score: Optional[float] = Field(None, description="Total session score including implementation and reviews (null if not yet calculated)")
    max_score: float = Field(..., description="Maximum possible score for this match")
    test_results: List[TestResultResponse] = Field(..., description="List of all test results")


class PeerReviewFeedbackResponse(BaseModel):
    """
    Response model for a single peer review feedback.
    """
    review_id: int = Field(..., description="ID of the review")
    reviewer_pseudonym: str = Field(..., description="Anonymous identifier for the reviewer")
    vote: str = Field(..., description="Vote: 'correct', 'incorrect', or 'skip'")
    vote_valid: Optional[bool] = Field(None, description="Whether the vote was validated as correct")
    comment: Optional[str] = Field(None, description="Reviewer's comment")
    proof_test_input: Optional[str] = Field(None, description="Proof test input (for incorrect votes)")
    proof_test_output: Optional[str] = Field(None, description="Expected proof test output")


class SolutionPeerReviewsResponse(BaseModel):
    """
    Response model for all peer reviews received on a solution.
    """
    solution_id: int = Field(..., description="ID of the solution")
    total_reviews: int = Field(..., description="Total number of reviews received")
    correct_votes: int = Field(..., description="Number of 'correct' votes")
    incorrect_votes: int = Field(..., description="Number of 'incorrect' votes")
    reviews: List[PeerReviewFeedbackResponse] = Field(..., description="List of peer reviews")



# ============================================================================
# Helper Functions
# ============================================================================



def _get_test_status(actual_output: str, expected_output: Optional[str]) -> str:
    """
    Determine test status.
    
    Args:
        actual_output: Output generated by student's code
        expected_output: Expected output from the test
    
    Returns:
        Status string: 'Passed', 'Failed', or 'Unknown'
    """
    if expected_output is None:
        # If no expected output is defined, we cannot determine pass/fail
        return "Unknown"
    
    # Simple string comparison (you may want to add more sophisticated comparison)
    if actual_output.strip() == expected_output.strip():
        return "Passed"
    else:
        return "Failed"


def _calculate_student_session_score(db: Session, student_id: int, game_id: int) -> float:
    """
    Calculate the total score for a student in a specific game session.
    
    Uses the same scoring logic as the leaderboard:
    - 50% Implementation: (total_points * 0.5) * (passed_tests / total_tests)
    - 50% Reviews (weighted system):
        - Ground truth: Correct solution (passed all teacher tests) vs Buggy (failed some)
        - Weights: Correct solution = 1, Buggy solution = 2
        - Unit value = (total_points * 0.5) / sum(weights)
        - Correct "correct" vote (confirmed a correct solution): +1 * unit_value
        - Correct "incorrect" vote (identified a buggy solution): +2 * unit_value
        - Wrong vote (vote doesn't match ground truth): -1 * unit_value (penalty)
        - Skip: 0 points
    
    Review correctness is determined by comparing the student's vote against the
    ground truth (whether the solution passed all teacher tests).
    
    Scores are capped at minimum 0 (no negative total scores).
    
    Args:
        db: Database session
        student_id: ID of the student
        game_id: ID of the game session
    
    Returns:
        Total score for this student in this game session (rounded to 2 decimal places)
    """
    total_score = 0.0
    
    # Get all matches_for_game for this game session
    matches_for_game_ids = db.query(MatchesForGame.match_for_game_id).filter(
        MatchesForGame.game_id == game_id
    ).all()
    match_for_game_id_list = [m[0] for m in matches_for_game_ids]
    
    if not match_for_game_id_list:
        return 0.0
    
    # ===== IMPLEMENTATION SCORE (50%) =====
    # Fetch student solution directly
    solution_data = db.query(
        StudentSolution.solution_id,
        StudentSolution.match_for_game_id,
        StudentSolution.passed_test,
        MatchSetting.total_points,
        MatchSetting.match_set_id
    ).join(
        MatchesForGame,
        MatchesForGame.match_for_game_id == StudentSolution.match_for_game_id
    ).join(
        Match,
        Match.match_id == MatchesForGame.match_id
    ).join(
        MatchSetting,
        MatchSetting.match_set_id == Match.match_set_id
    ).filter(
        StudentSolution.student_id == student_id,
        StudentSolution.match_for_game_id.in_(match_for_game_id_list)
    ).first()

    if not solution_data:
        return 0.0
    
    # Get total number of tests for this match setting
    total_tests = db.query(func.count(Test.test_id)).filter(
        Test.match_set_id == solution_data.match_set_id
    ).scalar()
    
    # Implementation score = 50% of total_points * (passed/total)
    if total_tests > 0:
        p_tests = solution_data.passed_test if solution_data.passed_test is not None else 0
        implementation_score = (solution_data.total_points * 0.5) * (p_tests / total_tests)
        total_score += implementation_score
    
    # ===== REVIEW SCORE (50%) =====
    # Fetch review vote results for this student in this game session, including passed_test count of the assigned solution
    review_data = db.query(
        StudentReviewVote.vote,
        StudentReviewVote.valid,
        StudentSolution.passed_test,
        MatchSetting.match_set_id,
        MatchSetting.total_points
    ).join(
        StudentAssignedReview,
        StudentAssignedReview.student_assigned_review_id == StudentReviewVote.student_assigned_review_id
    ).join(
        StudentSolution,
        StudentSolution.solution_id == StudentAssignedReview.assigned_solution_id
    ).join(
        MatchesForGame,
        MatchesForGame.match_for_game_id == StudentSolution.match_for_game_id
    ).join(
        Match,
        Match.match_id == MatchesForGame.match_id
    ).join(
        MatchSetting,
        MatchSetting.match_set_id == Match.match_set_id
    ).filter(
        StudentAssignedReview.student_id == student_id,
        StudentSolution.match_for_game_id.in_(match_for_game_id_list)
    ).all()
    
    # Calculate weights based on review pool
    # According to requirements:
    # 1. Identify Ground Truth: Correct (passed==total) vs Buggy (passed<total)
    # 2. Weights: Correct=1, Buggy=2
    # 3. Unit Value = (Points / Sum(Weights))
    
    if review_data:
        # Constraint: Student reviews solutions related to the same match_setting.
        # We can safely take the context from the first review.
        first_review = review_data[0]
        match_set_id = first_review.match_set_id
        current_total_points = first_review.total_points
        
        # Get total tests for this match_set (needed to determine if solution is correct/buggy)
        total_tests = db.query(func.count(Test.test_id)).filter(
            Test.match_set_id == match_set_id
        ).scalar()
        
        # Calculate Weights
        n_correct_sol = 0
        n_buggy_sol = 0
        
        for r in review_data:
            passed = r.passed_test if r.passed_test is not None else 0
            # Solution is correct if it passed all tests
            is_correct_sol = (passed == total_tests) and (total_tests > 0)
            
            if is_correct_sol:
                n_correct_sol += 1
            else:
                n_buggy_sol += 1
                
        total_weight = (n_correct_sol * 1) + (n_buggy_sol * 2)
        review_points_pool = current_total_points * 0.5
        
        unit_value = 0.0
        if total_weight > 0:
            unit_value = review_points_pool / total_weight
            
        # Apply Scores
        # Determine review correctness by comparing the actual vote against the ground truth
        for r in review_data:
            if r.vote == VoteType.skip:
                continue
                
            passed = r.passed_test if r.passed_test is not None else 0
            is_correct_sol = (passed == total_tests) and (total_tests > 0)
            
            # A vote is correct if it matches the ground truth:
            #   - Voted "correct" and solution IS correct (passed all teacher tests)
            #   - Voted "incorrect" and solution IS buggy (failed some teacher tests)
            if r.vote == VoteType.correct:
                vote_is_correct = is_correct_sol
            elif r.vote == VoteType.incorrect:
                vote_is_correct = not is_correct_sol
            else:
                continue
            
            if vote_is_correct:
                if is_correct_sol:
                    # Correctly voted "correct" on a correct solution -> weight 1
                    total_score += 1 * unit_value
                else:
                    # Correctly voted "incorrect" on a buggy solution -> weight 2
                    total_score += 2 * unit_value
            else:
                # Wrong vote -> Penalty -1 * unit_value
                total_score += -1 * unit_value
    
    # Cap minimum score at 0
    return round(max(0.0, min(total_score, solution_data.total_points)), 2)


def _calculate_and_save_session_scores(db: Session, game_id: int, force_recalculate: bool = False) -> tuple[Dict[int, float], bool]:
    """
    Calculate and save scores for all students in a game session.
    
    This should be called after Phase 2 ends to persist scores in the database.
    Optimized to skip calculation if scores are already calculated (idempotent).
    
    Uses database-level locking (SELECT FOR UPDATE) to prevent race conditions
    when multiple students hit this endpoint simultaneously.
    
    Args:
        db: Database session
        game_id: ID of the game session
        force_recalculate: If True, recalculate even if scores already exist
    
    Returns:
        Tuple of (Dictionary mapping student_id to their session score, was_already_calculated)
    """
    # FOR UPDATE prevents race condition when multiple
    student_joins = db.query(StudentJoinGame).filter(
        StudentJoinGame.game_id == game_id
    ).with_for_update().all()
    
    if not student_joins:
        return {}, False
    
    already_calculated = any(sj.session_score is not None for sj in student_joins)
    
    if already_calculated and not force_recalculate:
        db.commit()
        scores = {sj.student_id: float(sj.session_score) if sj.session_score is not None else 0.0 
                  for sj in student_joins}
        return scores, True
    
    scores: Dict[int, float] = {}
    
    for student_join in student_joins:
        score = _calculate_student_session_score(db, student_join.student_id, game_id)
        student_join.session_score = score
        scores[student_join.student_id] = score
        
        student = db.query(Student).filter(Student.student_id == student_join.student_id).first()
        if student:
            student.score += int(round(score))
    
    db.commit()  # Releases the lock
    
    return scores, False


# ============================================================================
# API Router
# ============================================================================

router = APIRouter(
    prefix="/api/student-results",
    tags=["Student Results and Scoring"]
)


# ============================================================================
# Endpoint 1: Get Test Results for Student Solution
# ============================================================================

@router.get(
    "/tests/{solution_id}",
    response_model=SolutionTestResultsResponse,
    status_code=status.HTTP_200_OK,
    summary="Get all test results for a student's solution",
    description="""
    Retrieves all test results (teacher and student tests) for a specific student solution.
    
    For each test case, displays:
    - Input and expected output
    - Actual output generated by the student's code
    - Status (Passed/Failed) with visual indicators (✓/✗)
    - Test type (teacher/student) and scope (public/private for teacher tests)
    
    Also calculates and displays the implementation score based on passed tests.
    """
)
def get_solution_test_results(
    current_user: Annotated[dict, Depends(get_current_user)],
    solution_id: int,
    db: Session = Depends(get_db)
) -> SolutionTestResultsResponse:
    """
    Get all test results for a specific student solution.
    
    Args:
        current_user: Authenticated user from JWT token
        solution_id: ID of the student solution
        db: Database session
    
    Returns:
        SolutionTestResultsResponse with all test results and score information
    
    Raises:
        HTTPException: If solution not found or user not authorized
    """
    authenticated_student_id = int(current_user["sub"])
    
    # Get the student solution
    solution = db.query(StudentSolution).filter(
        StudentSolution.solution_id == solution_id
    ).first()
    
    if not solution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student solution with ID {solution_id} not found"
        )
    
    # Verify the authenticated user owns this solution
    if solution.student_id != authenticated_student_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You are not authorized to view this solution"
        )
    
    # Get student information
    student = db.query(Student).filter(
        Student.student_id == solution.student_id
    ).first()
    
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {solution.student_id} not found"
        )
    
    # Get match and game information
    match_for_game = db.query(MatchesForGame).filter(
        MatchesForGame.match_for_game_id == solution.match_for_game_id
    ).first()
    
    if not match_for_game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match for game with ID {solution.match_for_game_id} not found"
        )
    
    match = db.query(Match).filter(
        Match.match_id == match_for_game.match_id
    ).first()
    
    if not match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match with ID {match_for_game.match_id} not found"
        )
    
    match_setting = db.query(MatchSetting).filter(
        MatchSetting.match_set_id == match.match_set_id
    ).first()

    if not match_setting:
         raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match Setting with ID {match.match_set_id} not found"
        )

    # Get all test results for this solution
    test_results_data = []
    passed_count = 0
    total_count = 0
    
    # Query all test results from student_solution_tests
    test_results = db.query(StudentSolutionTest).filter(
        StudentSolutionTest.solution_id == solution_id
    ).all()
    
    # Extract IDs
    teacher_test_ids = [tr.teacher_test_id for tr in test_results if tr.teacher_test_id is not None]
    student_test_ids = [tr.student_test_id for tr in test_results if tr.student_test_id is not None]
    
    # Fetch tests
    teacher_tests = db.query(Test).filter(Test.test_id.in_(teacher_test_ids)).all()
    student_tests = db.query(StudentTest).filter(StudentTest.test_id.in_(student_test_ids)).all()
    
    # Create lookup dictionaries
    teacher_test_map = {t.test_id: t for t in teacher_tests}
    student_test_map = {t.test_id: t for t in student_tests}
    
    for test_result in test_results:
        # Determine if this is a teacher test or student test result
        if test_result.teacher_test_id is not None:
            # Handle Teacher Test
            teacher_test = teacher_test_map.get(test_result.teacher_test_id)
            if not teacher_test:
                continue
                
            total_count += 1
            
            # Compare actual output with expected
            status_str = _get_test_status(
                test_result.test_output,
                teacher_test.test_out
            )
            
            if status_str == "Passed":
                passed_count += 1
                
            test_results_data.append(TestResultResponse(
                test_id=teacher_test.test_id,
                test_type="teacher",
                provider="teacher",
                scope=teacher_test.scope.value,
                test_input=teacher_test.test_in,
                expected_output=teacher_test.test_out,
                actual_output=test_result.test_output,
                status=status_str,
                comment=None  # Teacher tests don't have comments
            ))
            
        elif test_result.student_test_id is not None:
            # Handle Student Test
            student_test = student_test_map.get(test_result.student_test_id)
            if not student_test:
                continue
            
            
            # Compare actual output
            status_str = _get_test_status(
                test_result.test_output,
                student_test.test_out
            )
            
            test_results_data.append(TestResultResponse(
                test_id=student_test.test_id,
                test_type="student",
                provider="student",
                scope=None,
                test_input=student_test.test_in,
                expected_output=student_test.test_out,
                actual_output=test_result.test_output,
                status=status_str,
                comment=student_test.reviewer_comment  # Include reviewer's comment if present
            ))    
    
    # Calculate scores
             
    failed_count = total_count - passed_count
    
    # Get session_score from StudentJoinGame table (calculated after Phase 2 ends)
    student_join = db.query(StudentJoinGame).filter(
        and_(
            StudentJoinGame.student_id == solution.student_id,
            StudentJoinGame.game_id == match_for_game.game_id
        )
    ).first()
    
    session_score = student_join.session_score if student_join else None
    
    return SolutionTestResultsResponse(
        solution_id=solution.solution_id,
        student_id=student.student_id,
        student_name=f"{student.first_name} {student.last_name}",
        match_id=match.match_id,
        match_title=match.title,
        game_id=match_for_game.game_id,
        code=solution.code,
        total_tests=total_count,
        passed_tests=passed_count,
        failed_tests=failed_count,
        score_display=f"{passed_count}/{total_count} tests passed",
        session_score=session_score,
        max_score=match_setting.total_points,
        test_results=test_results_data
    )





# ============================================================================
# Endpoint 2: Get Peer Reviews for Student Solution
# ============================================================================

@router.get(
    "/reviews/{solution_id}",
    response_model=SolutionPeerReviewsResponse,
    status_code=status.HTTP_200_OK,
    summary="Get all peer reviews for a student's solution",
    description="""
    Retrieves all peer review feedback received on a specific student solution.
    
    Returns all votes (correct, incorrect, skip) with associated comments.
    Reviewers are displayed anonymously using pseudonyms.
    """
)
def get_solution_peer_reviews(
    current_user: Annotated[dict, Depends(get_current_user)],
    solution_id: int,
    db: Session = Depends(get_db)
) -> SolutionPeerReviewsResponse:
    """
    Get all peer reviews for a specific student solution.
    
    Args:
        current_user: Authenticated user from JWT token
        solution_id: ID of the student solution
        db: Database session
    
    Returns:
        SolutionPeerReviewsResponse with all peer reviews
    
    Raises:
        HTTPException: If solution not found or user not authorized
    """
    authenticated_student_id = int(current_user["sub"])
    
    # Get the solution and verify ownership
    solution = db.query(StudentSolution).filter(
        StudentSolution.solution_id == solution_id
    ).first()
    
    if not solution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student solution with ID {solution_id} not found"
        )
    
    # Verify the authenticated user owns this solution
    if solution.student_id != authenticated_student_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You are not authorized to view reviews for this solution"
        )
    
    # Query all reviews for this solution
    reviews = db.query(
        StudentReviewVote,
        StudentAssignedReview
    ).join(
        StudentAssignedReview,
        StudentAssignedReview.student_assigned_review_id == StudentReviewVote.student_assigned_review_id
    ).filter(
        StudentAssignedReview.assigned_solution_id == solution_id
    ).all()
    
    # Build response
    review_responses = []
    correct_count = 0
    incorrect_count = 0
    
    for idx, (vote, assigned_review) in enumerate(reviews, 1):
        vote_str = vote.vote.value if hasattr(vote.vote, 'value') else str(vote.vote)
        
        if vote_str == "correct":
            correct_count += 1
        elif vote_str == "incorrect":
            incorrect_count += 1
        
        review_responses.append(PeerReviewFeedbackResponse(
            review_id=vote.review_vote_id,
            reviewer_pseudonym=f"Reviewer #{idx}",
            vote=vote_str,
            vote_valid=vote.valid,
            comment=vote.note,
            proof_test_input=vote.proof_test_in if vote_str == "incorrect" else None,
            proof_test_output=vote.proof_test_out if vote_str == "incorrect" else None
        ))
    
    return SolutionPeerReviewsResponse(
        solution_id=solution_id,
        total_reviews=len(review_responses),
        correct_votes=correct_count,
        incorrect_votes=incorrect_count,
        reviews=review_responses
    )


# ============================================================================
# Endpoint 4: Get Student's Solution ID for a Game Session
# ============================================================================

class StudentSolutionIdResponse(BaseModel):
    """
    Response model for getting student's solution ID in a game session.
    """
    student_id: int = Field(..., description="ID of the student")
    game_id: int = Field(..., description="ID of the game session")
    solution_id: Optional[int] = Field(None, description="ID of the student's solution, if exists")
    has_solution: bool = Field(..., description="Whether the student has submitted a solution")


@router.get(
    "/solution/student/{student_id}/game/{game_id}",
    response_model=StudentSolutionIdResponse,
    status_code=status.HTTP_200_OK,
    summary="Get a student's solution ID for a game session",
    description="""
    Retrieves the solution ID for a specific student in a game session.
    
    This is useful for redirecting students to their results page after Phase 2 ends.
    Returns the solution_id if the student has submitted a solution, otherwise has_solution is false.
    """
)
def get_student_solution_id(
    current_user: Annotated[dict, Depends(get_current_user)],
    student_id: int,
    game_id: int,
    db: Session = Depends(get_db)
) -> StudentSolutionIdResponse:
    """
    Get the solution ID for a specific student in a game session.
    
    Args:
        current_user: Authenticated user from JWT token
        student_id: ID of the student
        game_id: ID of the game session
        db: Database session
    
    Returns:
        StudentSolutionIdResponse with solution ID if exists
    
    Raises:
        HTTPException: If student or game session not found, student not in game, or not authorized
    """
    authenticated_student_id = int(current_user["sub"])
    
    # Verify the authenticated user is requesting their own data
    if student_id != authenticated_student_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You are not authorized to access another student's solution"
        )
    
    # Verify student exists
    student = db.query(Student).filter(Student.student_id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {student_id} not found"
        )
    
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # Verify student is in the game session
    student_join = db.query(StudentJoinGame).filter(
        and_(
            StudentJoinGame.student_id == student_id,
            StudentJoinGame.game_id == game_id
        )
    ).first()
    
    if not student_join:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student {student_id} is not enrolled in game session {game_id}"
        )
    
    # Get the match_for_game for the student's assigned match
    match_for_game = db.query(MatchesForGame).filter(
        and_(
            MatchesForGame.game_id == game_id,
            MatchesForGame.match_id == student_join.assigned_match_id
        )
    ).first()
    
    if not match_for_game:
        return StudentSolutionIdResponse(
            student_id=student_id,
            game_id=game_id,
            solution_id=None,
            has_solution=False
        )
    
    # Get the student's solution for this match_for_game
    solution = db.query(StudentSolution).filter(
        and_(
            StudentSolution.student_id == student_id,
            StudentSolution.match_for_game_id == match_for_game.match_for_game_id
        )
    ).first()
    
    if not solution:
        return StudentSolutionIdResponse(
            student_id=student_id,
            game_id=game_id,
            solution_id=None,
            has_solution=False
        )
    
    return StudentSolutionIdResponse(
        student_id=student_id,
        game_id=game_id,
        solution_id=solution.solution_id,
        has_solution=True
    )


# ============================================================================
# Endpoint 5: Calculate and Save Session Scores
# ============================================================================

class SessionScoreEntry(BaseModel):
    """
    Response model for a student's session score entry.
    """
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    session_score: float = Field(..., description="Calculated session score")


class CalculateSessionScoresResponse(BaseModel):
    """
    Response model for calculating session scores.
    """
    game_id: int = Field(..., description="ID of the game session")
    game_name: str = Field(..., description="Name of the game session")
    message: str = Field(..., description="Status message")
    already_calculated: bool = Field(..., description="Whether scores were already calculated (skipped recalculation)")
    total_students: int = Field(..., description="Number of students scored")
    scores: List[SessionScoreEntry] = Field(..., description="List of student scores")


@router.post(
    "/calculate-scores/game/{game_id}",
    response_model=CalculateSessionScoresResponse,
    status_code=status.HTTP_200_OK,
    summary="Calculate and save scores for all students in a game session",
    description="""
    Calculates the final scores for all students in a game session and saves them
    to the database. This should be called after Phase 2 ends.
    
    Score calculation includes:
    - 50% Implementation: Based on tests passed
    - 50% Reviews: Based on review accuracy (correct error detection = 2x, correct confirm = 1x, wrong = -1x penalty)
    
    The calculated scores are saved to the student_join_game table and can be
    used by the leaderboard for efficient score aggregation.
    """
)
def calculate_and_save_game_session_scores(
    current_user: Annotated[dict, Depends(get_current_user)],
    game_id: int,
    db: Session = Depends(get_db)
) -> CalculateSessionScoresResponse:
    """
    Calculate and save scores for all students in a game session.
    
    Args:
        current_user: Authenticated user from JWT token
        game_id: ID of the game session
        db: Database session
    
    Returns:
        CalculateSessionScoresResponse with all calculated scores
    
    Raises:
        HTTPException: If game session not found
    """
    # Authentication is required, but any authenticated user can trigger score calculation
    # This is called when Phase 2 ends and students navigate to results
    
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    try:
        # Calculate and save all scores (skips if already calculated)
        scores, already_calculated = _calculate_and_save_session_scores(db, game_id)
        
        # Get student names for response
        score_entries = []
        for student_id, score in scores.items():
            student = db.query(Student).filter(Student.student_id == student_id).first()
            if student:
                score_entries.append(SessionScoreEntry(
                    student_id=student_id,
                    student_name=f"{student.first_name} {student.last_name}",
                    session_score=score
                ))
        
        # Sort by score descending
        score_entries.sort(key=lambda x: x.session_score, reverse=True)
        
        message = "Scores already calculated (skipped)" if already_calculated else "Scores calculated and saved successfully"
        
        return CalculateSessionScoresResponse(
            game_id=game_id,
            game_name=game.name,
            message=message,
            already_calculated=already_calculated,
            total_students=len(score_entries),
            scores=score_entries
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to calculate scores: {str(e)}"
        )


# ============================================================================
# Endpoint 6: Get Student's Session Score
# ============================================================================

class StudentSessionScoreResponse(BaseModel):
    """
    Response model for a student's session score.
    """
    student_id: int = Field(..., description="ID of the student")
    student_name: str = Field(..., description="Full name of the student")
    game_id: int = Field(..., description="ID of the game session")
    game_name: str = Field(..., description="Name of the game session")
    session_score: Optional[float] = Field(None, description="Session score (null if not yet calculated)")
    is_calculated: bool = Field(..., description="Whether the score has been calculated")


# ============================================================================
# Endpoint: Get All Session Scores for a Game
# ============================================================================


def get_game_session_scores_list(db: Session, game_id: int) -> List[Tuple[int, str, float]]:
    """
    Internal helper to get list of (student_id, username, score) for a game session.
    """
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # Get all students in the game session with their scores
    student_joins = db.query(StudentJoinGame).filter(
        StudentJoinGame.game_id == game_id
    ).all()
    
    if not student_joins:
        return []
    
    # Build list of tuples
    results = []
    for student_join in student_joins:
        student = db.query(Student).filter(Student.student_id == student_join.student_id).first()
        if student:
            score = float(student_join.session_score) if student_join.session_score is not None else 0.0
            username = f"{student.first_name} {student.last_name}"
            results.append((student.student_id, username, score))
    
    # Sort by score descending
    results.sort(key=lambda x: x[2], reverse=True)
    
    return results

@router.get(
    "/scores/game/{game_id}",
    response_model=List[Tuple[int, str, float]],
    status_code=status.HTTP_200_OK,
    summary="Get all session scores for a game session",
    description="""
    Retrieves all calculated session scores for a specific game session.
    Returns a list of tuples (student_id, username, score), sorted by score descending.
    Note: 'username' is the student's full name.
    """
)
def get_all_game_session_scores(
    current_user: Annotated[dict, Depends(get_current_user)],
    game_id: int,
    db: Session = Depends(get_db)
) -> List[Tuple[int, str, float]]:
    """
    Get all session scores for a specific game session.
    
    Args:
        current_user: Authenticated user from JWT token
        game_id: ID of the game session
        db: Database session
    
    Returns:
        List of tuples (student_id, username, score)
    
    Raises:
        HTTPException: If game session not found
    """
    return get_game_session_scores_list(db, game_id)



# ============================================================================
# Endpoint 6: Get Student's Session Score
# ============================================================================

@router.get(
    "/session-score/student/{student_id}/game/{game_id}",
    response_model=StudentSessionScoreResponse,
    status_code=status.HTTP_200_OK,
    summary="Get a student's session score for a game",
    description="""
    Retrieves the calculated session score for a specific student in a game session.
    Returns the score if it has been calculated, otherwise is_calculated is false.
    """
)
def get_student_session_score(
    current_user: Annotated[dict, Depends(get_current_user)],
    student_id: int,
    game_id: int,
    db: Session = Depends(get_db)
) -> StudentSessionScoreResponse:
    """
    Get the session score for a specific student in a game session.
    
    Args:
        current_user: Authenticated user from JWT token
        student_id: ID of the student
        game_id: ID of the game session
        db: Database session
    
    Returns:
        StudentSessionScoreResponse with session score if calculated
    
    Raises:
        HTTPException: If not authorized to view this student's score
    """
    authenticated_student_id = int(current_user["sub"])
    
    # Verify the authenticated user is requesting their own data
    if student_id != authenticated_student_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You are not authorized to access another student's score"
        )
    
    # Verify student exists
    student = db.query(Student).filter(Student.student_id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID {student_id} not found"
        )
    
    # Verify game session exists
    game = db.query(GameSession).filter(GameSession.game_id == game_id).first()
    if not game:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game session with ID {game_id} not found"
        )
    
    # Get the student_join_game record
    student_join = db.query(StudentJoinGame).filter(
        and_(
            StudentJoinGame.student_id == student_id,
            StudentJoinGame.game_id == game_id
        )
    ).first()
    
    if not student_join:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student {student_id} is not enrolled in game session {game_id}"
        )
    
    return StudentSessionScoreResponse(
        student_id=student_id,
        student_name=f"{student.first_name} {student.last_name}",
        game_id=game_id,
        game_name=game.name,
        session_score=student_join.session_score,
        is_calculated=student_join.session_score is not None
    )
